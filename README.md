# Uno.Diagnostics.Eventing

A set of packages and tools that enable the use of the [Windows Performance Analyzer](https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-analyzer) tooling with iOS, Android and WebAssembly.

## Event Tracing using Uno

Uno provides an abstraction for event tracing that allows for the generation
of custom trace events to be visualized in the WPA tools from the Windows Platform SDK.

An trace event is a timestamped data structure that can be mapped on a timeline, correlated
with other events, such as start/stop pairs and related events.

While Windows provides the registration and authoring of event sources natively, other platforms do not provide this, and 
Uno provides this abstraction through `IEventProvider`.

## Creating a trace source

The creation of a tracing source requires a nested class named `TraceProvider`, with an `Id` member
of type `Guid`, and fields of type int for event type available.

This nested class is required for the creation of the trace manifest generated by the FileEventSink.

```csharp
public class MyDummy
{
    // Gets the event provider for the specified Id
    private readonly static IEventProvider _trace = Tracing.Get(TraceProvider.Id);

    // This class must be nested, and named TraceProvider
    public static class TraceProvider
    {
        public readonly static Guid Id = Guid.Parse("{EA0762E9-1234-1234-XXXX-CC7ECF7BE85E}");

        public const int MyDummy_Created = 1;
        public const int MyDummy_ProcessingStart = 2;
        public const int MyDummy_ProcessingStop = 3;
        public const int MyDummy_ProcessingException = 4;
    }

    public MyDummy()
    {
        // The test is performed before calling the WriteEvent method for performance.
        // Testing a variable is particurlarly cheap, and calling WriteEvent with parameters
        // to be discarded may be a waste of CPU time.

        if (_trace.IsEnabled)
        {
            _trace.WriteEvent(TraceProvider.MyDummy_Created, EventOpcode.Send, new[] { GetType().ToString() });
        }
    }

    public void MyProcessing()
    {
        // The test is performed before calling the WriteEvent method for performance.
        // Testing a variable is particurlarly cheap, and calling WriteEvent with parameters
        // to be discarded may be a waste of CPU time.

        try
        {
            using (
                _trace.WriteEventActivity(
                    TraceProvider.MyDummy_ProcessingStart,
                    TraceProvider.MyDummy_ProcessingStop,
                    relatedActivity: scheduledItem.SourceActivity
                )
            )
            {
                // Do something
            }
        }
        catch(Exception e)
        {
            if (_trace.IsEnabled)
            {
                _trace.WriteEvent(MyDummy_ProcessingException, new[] { e.ToString() });
            }
        }
    }
}
```
In some cases, for performance reasons, it way be relevant to write activity-based tracing this way:

``` csharp
IDisposable traceActivity = null;
if (_trace.IsEnabled)
{
    traceActivity = _trace.WriteEventActivity(
        TraceProvider.ArrangeStart,
        TraceProvider.ArrangeStop,
        new object[] { GetType().ToString(), Panel.GetDependencyObjectId() });
}
using (traceActivity)
{
    ArrangeOverride(finalSize);
}
```

Which avoids the creation of a temporary set of variables used for the tracing. Another explored way to do this
would have been using a lambda for the payload parameter, but it still creates a delegate and closure over some
variables, which has a cost.


## Prepare your workstation for tracing

### PerfView

Ensure you have the latest version of **PerfView**. You can download it from the following
link:

<https://github.com/Microsoft/perfview/releases> (executable, there's no installer)

> **PerfView** is the tool used to gather metrics while the application is running
> (or to translate from Android & iOS)

### WPA - Windows Performance Analyzer

You must have **Windows Performance Analyzer** (_WPA_) installed on your machine. This tool
is installed from the _Windows SDK_. To install it:

  1. Right-click on _Start_ on Windows
  2. Click `Apps & Features` (usually the first menu option)
  3. Locate the most recent version of `Windows Software Development Kit` installed
     on your machine (you should have more than one, use version number to locate the latest)
  4. Click `Modify`
  5. Click `Next` (operation should be `Change`)
  6. Check the `Windows Performance Toolkit` (usually the first option)

> **Windows Performance Analyzer** is the tool to analyze the result.

## Prepare your app for tracing

The tracing output will be composed of two files: the trace file and the trace manifest.

The trace file contains the raw data of the events, which will be transformed into an ETL
file in a later step. The manifest file contains the description of all the event source found
via reflection in all the public classes available in the current AppDomain.

1. You must ensure you have the following nuget package installed in your project:
   `Uno.Diagnostics.Eventing.Providers`

2. Activate the tracing is done through the following on Android:

   **For Android**

   ``` csharp
        public static void Android_EnableTracing()
        {
            Uno.Diagnostics.Eventing.Tracing.IsEnabled = true;

            var traceFolder = Android.OS.Environment.GetExternalStoragePublicDirectory(Android.OS.Environment.DirectoryDocuments);

            if (!traceFolder.Exists())
            {
                traceFolder.Mkdirs();
            }

            // You may need to add permission WRITE_EXTERNAL_STORAGE in manifest
            // to avoid the next line to produce a System.UnauthorizedAccessException
            Uno.Diagnostics.Eventing.Tracing.Factory =
                new Uno.Services.Diagnostics.Eventing.EventProviderFactory(
                    new Uno.Services.Diagnostics.Eventing.FileEventSink(traceFolder.AbsolutePath)
                );

            Android_EnableUnoTracing();
        }

        public static void Android_EnableUnoTracing()
        {
            Uno.Diagnostics.Eventing.Tracing.IsEnabled = true;

            Uno.Diagnostics.Eventing.Tracing.Factory =
                new Uno.Services.Diagnostics.Eventing.UnoEventProviderFactory(
                    Uno.Diagnostics.Eventing.Tracing.Factory
                );
        }
    ```

   **For iOS**:

   ``` csharp
        public static void IOS_EnableTracing()
        {
            Uno.Diagnostics.Eventing.Tracing.IsEnabled = true;

            var traceFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);

            var traceUnoFolder = Path.Combine(traceFolder, "UnoTrace");

            if (!Directory.Exists(traceUnoFolder))
            {
                Directory.CreateDirectory(traceUnoFolder);
            }

            Uno.Diagnostics.Eventing.Tracing.Factory =
                new Uno.Services.Diagnostics.Eventing.EventProviderFactory(
                    new Uno.Services.Diagnostics.Eventing.FileEventSink(traceUnoFolder)
                );

            iOS_EnableUnoTracing();
        }

        public static void iOS_EnableUnoTracing()
        {
            Uno.Diagnostics.Eventing.Tracing.IsEnabled = true;

            Uno.Diagnostics.Eventing.Tracing.Factory =
                new Uno.Services.Diagnostics.Eventing.UnoEventProviderFactory(
                    Uno.Diagnostics.Eventing.Tracing.Factory
                );
        }
    ```

   **For Windows (UWP)**

   ``` csharp
        public static void EnableTracing()
        {
            Uno.Diagnostics.Eventing.Tracing.IsEnabled = true;

            Uno.Diagnostics.Eventing.Tracing.Factory =
                new Uno.Services.Diagnostics.Eventing.EventProviderFactory();
        }
    ```

## Capturing Traces **on Windows**

1. Run the application first using a debugger and look for the `Available providers:` providers line.
2. Download [PerfView](https://github.com/Microsoft/perfview/releases) from Microsoft.
3. Run perfview in command line using the following arguments:
    `perfview /onlyProviders=[content_of_the_providers_log_above** collect output01 -zip:false`
4. Run the application again
5. Stop the Perfview trace
6. Open the trace with `WPA` (see the section below)

> **IMPORTANT**: you should ensure no other software are consuming I/O or CPU during the capture:
> this can alter the result.

## Capturing Traces **on Android and iOS**

Run the application to fill the trace file, which will give as many trace points as necessary.

**Make sure that the tracing is enabled as soon as possible in your application**, otherwise, some components that are started early may not be traced (such as Uno's IoC container).

* On Android, place the initialization in the clas that inherits from `Android.Application`.
* On iOS, place the intialization at **first line of the main.cs** file.


## Transforming the Uno trace file in a Windows ETL file (**iOS & Android ONLY**)

The transform tool is a runtime replay tool because as the time of writing, the ETL file format is
closed, and the available APIs don't allow the creation of custom events, and particularly don't allow
for setting the timestamp or threadId of a trace event.
This means that for a trace file that was taken over 55 seconds, the transform tool will run for 55
seconds, replaying the events one by one at the appropriate relative time.

1. Grab the trace files :

    * For Android :
        * Determine the path using the ADB logcat, one of the first logging lines will indicate the path to pull
        * Most of the time, running `adb pull /mnt/sdcard/Documents/traces` will be enough.
    * For iOS:
        * Get the container for the installed app using the XCode devices window, or using the file location given by the VS output window.

2. Transform the trace files using the Uno.ETLTranslator tool, in the Uno solution.

    1. Download [PerfView](http://www.microsoft.com/en-ca/download/details.aspx?id=28567) from Microsoft.
    2. Set the first parameter of the executable to the .trace file you just pulled from the device
    3. Run the converter
    4. When asked, copy/paste and run the Perfview command line into another *Command Prompt* window
    5. Make converter continue and finish.
    6. Press the stop collection button in PerfView
    7. Extract the ETL file from the file PerfView created

Note that enabling the Xamarin linker removes the trace hints, making the manifest file empty. In such a
case, generate a manifest file using a debug build with the linking disabled, in a simulator (to build quickly).

> **IMPORTANT**: you should ensure no other software are consuming I/O or CPU during the translation,
> this cause noise in the result.

## Visualizing the trace using Windows Performance Analyzer (WPA)

WPA is a very powerful, yet very complex tool. The amount of information available may be confusing at
first, but given a bit of time, some patterns start to emerge.

To visualize a trace file :

1. Double click it to open, which should start WPA
   (alternatively you can type `start <file>.etl` from command line)
2. In the Pofiles menu, click **browse**, then select the file named
   `Content\umbrella.ui.wpaProfile` in the Uno.ETLTranslator project (Uno project).
3. Pre-configured windows will open to profile somehow relevant information.

In the analysis tab, individual the events are displayed. In the tabular view of the generic events window,
most of the events will have payload information that detail the events such as the priority of an Background task
schedule, or the URI of a Web request.

In the Regions of Interest window, the Start/Stop event are materialized more accurately, giving actual time periods
for activities. This can provide duration information about asynchronous operations such as web requests, async
methods, etc...

## How to interpret the traces

Uno and Uno components provide out-of-the-box trace providers, which can be analyzer to provide details
of the application's behavior, down to the microsecond.

The regions of interest are sorted by the longest to lowest regions, which means that expanding a provider's node
will give a good idea of what's costly. When clicking the a region, every region below in the blue highlighted
zones will be a child of this region, meaning that this region's duration is inclusing of its children. It may
be interesting to check those children regions for performance issues.
